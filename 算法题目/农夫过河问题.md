# 农夫过河问题

## 问题描述

农夫把狼，羊，菜运到对岸，一次只能运一个，且狼和羊，羊和菜不能在一起。



## 代码

### 定义枚举和结构体

#### 动作枚举值

```c
// 状态定义（推测）
struct ItemState {
    bool farmerOnLeft;   // 农夫在左岸
    bool wolfOnLeft;     // 狼在左岸
    bool sheepOnLeft;    // 羊在左岸
    bool vegetableOnLeft;// 蔬菜在左岸
};
```

#### 定义结构体

```c
//定义
struct ActionProcess {
    Action act;//
    ProcessNextFuncPtr processFunc;
};
```





### 建立动作枚举值与处理函数的映射关系

```c
//建立动作枚举值与处理函数的映射关系
ActionProcess actMap[] = {
    { FARMER_GO, ProcessFarmerGo },//农夫独自过河
    { FARMER_GO_TAKE_WOLF, ProcessFarmerGoTakeWolf },//农夫带狼过河
    { FARMER_GO_TAKE_SHEEP, ProcessFarmerGoTakeSheep },//农夫带羊过河
    { FARMER_GO_TAKE_VEGETABLE, ProcessFarmerGoTakeVegetable },//农夫带蔬菜过河
    { FARMER_BACK, ProcessFarmerBack },//农夫独自返回
    { FARMER_BACK_TAKE_WOLF, ProcessFarmerBackTakeWolf },//农夫带狼返回
    { FARMER_BACK_TAKE_SHEEP, ProcessFarmerBackTakeSheep },//农夫带羊返回
    { FARMER_BACK_TAKE_VEGETABLE, ProcessFarmerBackTakeVegetable }//农夫带蔬菜返回
};
```



### 定义函数指针

```c
//定义
typedef bool (*ProcessNextFuncPtr)(const ItemState& current, ItemState& next);
//ProcessNextFuncPtr：函数名
//current：动作枚举值
//next：处理函数
```



### 状态转移逻辑

```c
//状态转移逻辑
ItemState next;//声明一个基础状态

for(int i = 0; i < sizeof(actMap)/sizeof(actMap[0]); i++) {
    if(actMap[i].act == action)  // 查找匹配的动作
    {
        actMap[i].processFunc(current, next);  // 执行对应的状态转移函数
        break;
    }
}
```

